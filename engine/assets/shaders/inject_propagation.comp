#version 450
#extension GL_ARB_shader_image_load_store : require
layout (local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

layout(binding = 0, rgba8) uniform readonly image3D voxelAlbedo;
layout(binding = 1, rgba8) uniform readonly image3D voxelNormal;
layout(binding = 2, rgba8) uniform writeonly image3D voxelComposite;
layout(binding = 3, rgba8) uniform sampler3D voxelTex;
layout(binding = 4, rgba8) uniform sampler3D voxelTexMipmap[6];

const float PI = 3.14159265f;
const float EPSILON = 1e-30;
uniform float maxTracingDistanceGlobal = 1.0f;
uniform int volumeDimension;
uniform float voxelSize;
uniform float voxelScale;
uniform vec3 worldMinPoint;

// four cones
const vec3 propagationDirections[] =
{
    vec3(0.0f, 1.0f, 0.0f),
    vec3(0.0f, 0.5f, 0.866025f),
    vec3(0.754996f, 0.5f, -0.4330128f),
    vec3(-0.754996f, 0.5f, -0.4330128f)
};

const float diffuseConeWeights[] =
{
    PI / 2.0f,
    PI / 6.0f,
    PI / 6.0f,
    PI / 6.0f,
};

vec3 VoxelToWorld(ivec3 pos)
{
    vec3 result = vec3(pos);
    result *= voxelSize;

    return result + worldMinPoint;
}

vec3 WorldToVoxel(vec3 position)
{
    vec3 voxelPos = position - worldMinPoint;
    return voxelPos * voxelScale;
}

vec4 TraceCone(vec3 position, vec3 direction, float aperture, float maxTracingDistance)
{
    uvec3 visibleFace;
    visibleFace.x = (direction.x < 0.0) ? 0 : 1;
    visibleFace.y = (direction.y < 0.0) ? 2 : 3;
    visibleFace.z = (direction.z < 0.0) ? 4 : 5;
    // in propagation mode we only trace the mip levels for 
    // speed and to avoid aliasing issues
    float anisoDimension = volumeDimension / 2.0f;
    // weight per axis for aniso sampling
    vec3 weight = direction * direction;
    // navigation
    float voxelSize = 1.0f / anisoDimension;
    // move one voxel further to avoid self collision
    float dst = voxelSize * 2.0f;
    float diameter = aperture * dst;
    vec3 samplePos = direction * dst + position;
    // control vars
    float mipLevel = 0.0f;
    float mipMaxLevel = log2(anisoDimension) - 1.0f;
    // accumulated sample
    vec4 coneSample = vec4(0.0f);
    vec4 anisoSample = vec4(0.0f);

    while(coneSample.a <= 1.0f && dst <= maxTracingDistance && dst <= maxTracingDistanceGlobal)
    {
        // outisde bounds
        if (aperture < 0.3f && (samplePos.x < 0.0f || samplePos.y < 0.0f || samplePos.z < 0.0f
            || samplePos.x > 1.0f || samplePos.y > 1.0f || samplePos.z > 1.0f)) 
        { 
            break; 
        }

        mipLevel = clamp(log2(diameter * anisoDimension), 0.0f, mipMaxLevel);
        // aniso sampling
        anisoSample = weight.x * textureLod(voxelTexMipmap[visibleFace.x], samplePos, mipLevel)
                    + weight.y * textureLod(voxelTexMipmap[visibleFace.y], samplePos, mipLevel)
                    + weight.z * textureLod(voxelTexMipmap[visibleFace.z], samplePos, mipLevel);
        // accumulate sampling
        coneSample += (1.0f - coneSample.a) * anisoSample;
        // move further into volume
        dst += max(diameter, voxelSize);
        diameter = dst * aperture;
        samplePos = direction * dst + position;
    }

    return coneSample;
}

vec4 CalculateIndirectLighting(vec3 position, vec3 normal)
{
    // move position a bit further along the normal to avoid artifacts
    vec3 unitCubeDirection = clamp(1.7320f * normal, -1.0f, 1.0f);  
    position = position + unitCubeDirection * voxelSize;
    // to voxel position
    vec3 positionT = WorldToVoxel(position);    
    // cummulative
    vec4 diffuseTrace = vec4(0.0f);

    // diffuse cone setup
    float aperture = 0.6283f;
    vec3 guide = vec3(0.0f, 1.0f, 0.0f);

    if (abs(dot(normal,guide)) == 1.0f)
    {
        guide = vec3(0.0f, 0.0f, 1.0f);
    }

    // Find a tangent and a bitangent
    vec3 right = normalize(guide - dot(normal, guide) * normal);
    vec3 up = cross(right, normal);

    for(int i = 0; i < 4; i++)
    {
        vec3 coneDirection = normal;
        coneDirection += propagationDirections[i].x * right + propagationDirections[i].z * up;
        coneDirection = normalize(coneDirection);

        diffuseTrace += TraceCone(positionT, coneDirection, aperture, 1.0f) * diffuseConeWeights[i];
    }

    return clamp(diffuseTrace, 0.0f, 1.0f);
}

void main()
{
    if(gl_GlobalInvocationID.x >= volumeDimension ||
        gl_GlobalInvocationID.y >= volumeDimension ||
        gl_GlobalInvocationID.z >= volumeDimension) return;

    ivec3 writePos = ivec3(gl_GlobalInvocationID);
    vec4 albedo = imageLoad(voxelAlbedo, writePos);

    if(albedo.a == 0.0f) { return; }

    vec4 injectionPass = texelFetch(voxelTex, writePos, 0);
    // normal from voxelization
    vec3 normal = imageLoad(voxelNormal, writePos).xyz;
    // normal is stored in 0-1 range, restore to -1 -> -1
    normal = normalize(normal * 2.0f - 1.0f);
    // calculate indirect lighting - first bounce onto the voxel texture
    vec3 wsPosition = VoxelToWorld(writePos);
    vec4 indirectLighting = CalculateIndirectLighting(wsPosition, normal);
    // first bounce gi component only
    vec4 firstBounce = indirectLighting * albedo;
    // first bounce + direct lighting
    vec4 radiance = injectionPass + firstBounce;
    radiance.a = injectionPass.a;

    imageStore(voxelComposite, writePos, clamp(radiance, 0.0f, 1.0f));
}