#version 430
layout (local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

layout(binding = 0, r32ui) uniform uimage3D voxelAlbedo;
layout(binding = 1, r32ui) uniform uimage3D voxelNormal;
layout(binding = 2, rgba8) uniform writeonly image3D voxelRadiance;

struct Light 
{
    vec3 diffuse;
    vec3 direction;
};

uniform vec2 exponents;
uniform float lightBleedingReduction;
uniform mat4 lightViewProjection;
uniform Light directionalLight;
uniform float voxelSize;

uniform sampler2D shadowMap;
uniform uint castShadow = 1;

vec3 Diffuse(Light light, vec3 lightDirection, vec3 normal, vec3 albedo)
{
    float lambertian = clamp(dot(normal, lightDirection), 0.0f, 1.0f);
    return light.diffuse * albedo * lambertian;
}

float linstep(float low, float high, float value)
{
    return clamp((value - low) / (high - low), 0.0f, 1.0f);
}  

float ReduceLightBleeding(float pMax, float Amount)  
{  
    return linstep(Amount, 1, pMax);  
} 

vec2 WarpDepth(float depth)
{
    depth = 2.0f * depth - 1.0f;
    float pos = exp(exponents.x * depth);
    float neg = -exp(-exponents.y * depth);
    return vec2(pos, neg);
}

float Chebyshev(vec2 moments, float mean, float minVariance)
{
    if(mean <= moments.x)
    {
        return 1.0f;
    }
    else
    {
        float variance = moments.y - (moments.x * moments.x);
        variance = max(variance, minVariance);
        float d = mean - moments.x;
        float lit = variance / (variance + (d * d));
        return ReduceLightBleeding(lit, lightBleedingReduction);
    }
}

float Visibility(vec3 position)
{
    vec4 lsPos = lightViewProjection * vec4(position, 1.0f);
    // avoid arithmetic error
    if(lsPos.w == 0.0f) return 1.0f;
    // transform to ndc-space
    lsPos /= lsPos.w;
    // querry visibility
    vec4 moments = texture(shadowMap, lsPos.xy).xyzw;
    // move to avoid acne
    vec2 wDepth = WarpDepth(lsPos.z - 0.0001f);
    // derivative of warping at depth
    vec2 depthScale = 0.0002f * exponents * wDepth;
    vec2 minVariance = depthScale * depthScale;
    // evsm mode 4 compares negative and positive
    float positive = Chebyshev(moments.xz, wDepth.x, minVariance.x);
    float negative = Chebyshev(moments.yw, wDepth.y, minVariance.y);
    // shadowing value
    return min(positive, negative);
}

vec4 convRGBA8ToVec4(uint val)
{
    return vec4(float((val & 0x000000FF)), 
    float((val & 0x0000FF00) >> 8U), 
    float((val & 0x00FF0000) >> 16U), 
    float((val & 0xFF000000) >> 24U));
}

uniform struct Matrices
{
    mat4 model;
} matrices;

void main()
{
	uvec3 volumeDimension = imageSize(voxelAlbedo);

	if(gl_GlobalInvocationID.x >= volumeDimension.x ||
		gl_GlobalInvocationID.y >= volumeDimension.y ||
		gl_GlobalInvocationID.z >= volumeDimension.z) return;

	ivec3 writePos = ivec3(gl_GlobalInvocationID);

	// get r32ui encoded value
	uvec4 albedoEnc = imageLoad(voxelAlbedo, writePos);
	uvec4 normalEnc = imageLoad(voxelNormal, writePos);

	// empty voxel
	if(albedoEnc.x == 0) { return; }

	// convert to more manageable 0->1 float components
	vec4 albedo = convRGBA8ToVec4(albedoEnc.x) / 255.0f;
	albedo.a = 1.0f;

	vec3 normal = (convRGBA8ToVec4(normalEnc.x) / 255.0f).xyz;
	// normal is stored in 0-1 range, restore to -1-1
	normal = normalize(normal * 2.0f - 1.0f);

	// obtain ws position of the current voxel
	vec4 wsPosition = vec4(writePos, 1.0f);
	wsPosition = matrices.model * wsPosition;

	albedo.rgb = Diffuse(directionalLight, directionalLight.direction, normal, albedo.rgb);

	vec3 unitCubeDirection = vec3(clamp(2.0f * normal, vec3(-1.0f), vec3(1.0f)));
	
	if(castShadow == 1)
	{
		albedo *= Visibility(wsPosition.xyz + unitCubeDirection * voxelSize);
	}

	albedo.a = 1.0f;

	imageStore(voxelRadiance, writePos, albedo);
}